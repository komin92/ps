##############################################################################																			## name: po_timed.ps1														## script version 0.9														## 																			#	# author: eduard-albert.prinz									##																			## comment: 	execute with task scheduler	to timed poweroff client(s)		 	##																			## 20.02.2013 :: release														##																			##############################################################################param (	[string]$regex = "" )$nl = [environment]::newline$clientfile = "\\$env:server\utils$\clients.csv"[int]$stop = 0[int]$time = 0[int]$crossings = 3[string]$client = ""$jobs = @()$clientlistcount = 0$date = ( get-date ).tostring('dd_MM_yyyy_HH_mm_ss')	# ---------------------------------------------------------------------------#logging to customize# ---------------------------------------------------------------------------$logdir = "$env:emp_utils"+"shutdownjobs\"$logfile = [string]::join('',($regex, "_$date.log"))$logfile = [string]::join('',($logdir, $logfile))if (!$(test-path $logdir)) {new-item $logdir -itemtype directory | out-null}if (!$(test-path $logfile)) {new-item -type file $logfile -force}$args | %{	switch ($_) {		stop {[int]$stop = 1 }		default {if($_ -match "^[\d\.]+$"){$time = $_}}	}}function writelog{[cmdletbinding()]	param (			[string]$msg = ""				)	$logrecord = "------------------------------------------------------------$nl $((get-date).tostring())" 	$logrecord += $msg	add-content -literalpath $logfile -value $logrecord}if($stop){	$jobs = @()	$jobs = get-job	$jobs | % { if(($_.state -eq "completed") -or ($_.state -eq "stopped") -or ($_.state -eq "failed")){remove-job $_.id} }	$data = get-content –path $clientfile	$clientlist = @()	$count = 0	foreach ($row in $data){	  $fields = $row.split(',')  	  $clientlist += $fields[0] 	  $count++  	}	$newclientlist = @()	   	for($i=0; $i -lt $clientlist.count; $i++){		try{ if($clientlist[$i] -match $regex){ $newclientlist += $clientlist[$i] }	}		catch{			$errormessage = $_.exception.message			$logmsg = "$nl incorrect regex syntax: $regex - please try again. $nl" 			writelog $logmsg		}    		}	$newclientlist.getenumerator() | sort-object value	$clientlistcount = $newclientlist.count; $jobdescription = ""	$logmsg = " poweroff computer in $time minutes for '$regex', $clientlistcount pc(s): "; writelog $logmsg;		for($i=0; $i -lt $clientlistcount; $i++){		$client = $newclientlist[$i]		$logmsg = " try to start-job for $client "		writelog $logmsg		try{ 			start-job -name $client -scriptblock{					param($computername, $time, $logfile, $crossings)				$nl = [environment]::newline				function writelog{				[cmdletbinding()]					param( [string]$msg = "" )					$logrecord = "------------------------------------------------------------$nl $((get-date).tostring())" 					$logrecord += $msg					add-content -literalpath $logfile -value $logrecord				}				$global:seconds							function countdown([int]$seconds)				{					while ($seconds -ge 1){						start-sleep -seconds 1							$seconds --					}				}				$ping = new-object system.net.networkinformation.ping							try{ $pingreturns = $ping.send($computername, 1000) }				catch{ 					$logmsg = "Ping request could host $computername not found."					writelog $logmsg 								}		  				if($pingreturns.status -ne "success"){						$logmsg = " $computername down "						writelog $logmsg				}else{										if($time -gt 0){						$quotient = ($time/$crossings)						$global:seconds = ($quotient*60)						for($i=0; $i -lt $crossings; $i++){							[string]$msgstop="this computer will stop in $time minutes.  please log off."												[string]$session="*"							$command = "msg.exe $session /time:60"							if($computername){ $command += " /server:$($computername)" }							$command += " $($msgstop)"							invoke-expression $command 							countdown -seconds $global:seconds							$time = ($time - $quotient)								}								}					try { 						$logmsg = " try stop : $computername `n"						stop-computer -comp $computername -force										$logmsg = " $computername stop success"							writelog $logmsg								}					catch{ 						$errormessage = $_.exception.message										$logmsg = " stop failed for $computername the error message was $errormessage "						writelog $logmsg										}						}									} -argumentlist $client, $time, $logfile, $crossings 		}		catch{			$errormessage = $_.exception.message			writelog $errormessage					}    			}	writelog " jobs running: $(@(get-job -state running).count) "	get-job | wait-job | out-null	writelog " jobs: $(@(get-job -state completed).count) completed "	try { remove-job -state completed }	catch{		$errormessage = $_.exception.message		writelog $errormessage					}		exit}